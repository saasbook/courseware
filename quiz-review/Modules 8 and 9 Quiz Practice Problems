# **Module 8 Problems:**

Correct answers are **bolded**.

<span style="text-decoration:underline;">FIRST Principles:</span>

The RSpec testing framework conducts “test teardown” by erasing the database and reloading fixtures before a test is run. This ensures that tests stay:

Fast

**Independent**

Repeatable

Self-checking

Timely

<span style="text-decoration:underline;">Enormous Test Suite:</span>

Before running my enormous test suite of 300 Cucumber scenarios, I decide to load my app in the browser and visit the home page to confirm that it displays correctly. I find that nothing is obviously wrong with the website from my initial inspection. This was an example of:

Stress testing

Accessibility testing

**Smoke testing**

Regression testing

**Functional testing**

<span style="text-decoration:underline;">Testing Categories:</span>

Match the test to the technique being used:

- **Mutation Testing**:
  - A test which automatically replaces an instance of the line “a = b + c” with the line “a = b - c” inside a critical function in the code.

- **Fuzz Testing**:
  - A test that checks if a computer vision model has been severely overfitted by randomly generating hundreds of images of blobs and checking whether those blobs are detected as “chickens.”

- **Black-box Testing**:
  - A test which ensures that passing in -1 to a square root function raises an error.

- **White-box Testing**:
  - A test which ensures that every possible code path of a certain function gets traversed.




<span style="text-decoration:underline;">Mocks, Doubles, Factories, and Fixtures:</span>

Which of the following statements are true about mocks, doubles, factories, and fixtures?

**The main benefit of stubbing out external services is that tests can remain fast and repeatable**

Factories are preferred over fixtures for data that stays constant across all tests

All objects from a certain factory are the same

If a certain code path of a test can only be tested on one day of the entire year the test violates the FIRST principle of timeliness

**Even though RSpec doubles provide stand-ins for nonexistent methods, they would override methods that did actually exist in the code**

<span style="text-decoration:underline;">Code Coverage:</span>

Which of the following are generally true about code coverage metrics?

100 percent code coverage guarantees the code you have written will work correctly.

**C0 coverage measures how many statements of your codebase are covered by tests.**

C1 coverage measures how many of the available code paths have been taken in your codebase.

**The code-to-test-ratio metric is the most “rough” measure of code coverage.**

**High C2 coverage is more difficult to achieve comparatively to C0 & C1 coverage.**

<span style="text-decoration:underline;">Addendum:</span> We highly recommend doing CHIPS 8.5 PART 1 BEFORE taking the Module 8 quiz.


# **Module 9 Problems:**

<span style="text-decoration:underline;">Goals of Refactoring:</span>

Which of the following are primary goals of refactoring?

Improving test coverage

**Making the code easier to test**

Reducing the amount of code

Increasing code complexity

**Eliminating code smells**

<span style="text-decoration:underline;">Smelly Code:</span>

What statements are true about code smells?

**Methods with higher cyclomatic complexity scores tend to require more exhaustive testing to achieve higher C2 coverage**

**The ABC score for a method is positively related to the number of branches in that method**

**Long methods tend to be a symptom of either too many method arguments, the method not maintaining a consistent level of abstraction, or the method doing more than one thing**

**A good way to prevent repetitive pieces of code in many sections of your program is to use the _Extract Method_ refactoring strategy**

<span style="text-decoration:underline;">Forms of Testing:</span>

Which statement(s) best describe the different kinds of testing?

**Unit tests and module tests rely more on detailed knowledge about the system’s implementation than integration/acceptance tests**

Characterization tests violate the principles of test-driven development since they are written after rather than before the code

Legacy codebases are best explored using integration-level tests since the interfaces between different units often have inconsistent assumptions

Characterization tests should typically only be implemented at the integration level or above since unit/module test logic is generally very complicated and difficult to understand

<span style="text-decoration:underline;">Other topics to review:</span> Agile/XP from Module 7